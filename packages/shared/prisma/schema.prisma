// Sentinel - Change Intelligence Platform
// Prisma Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =====================
// ENUMS
// =====================

enum WorkspaceType {
  ecommerce
  competitor
  procurement
}

enum WorkspaceRole {
  owner
  admin
  member
  viewer
}

enum FetchMode {
  http
  headless
  flaresolverr
}

enum FetchOutcome {
  ok
  blocked
  captcha_required
  empty
  timeout
  network_error
  provider_error
  rate_limited
  interstitial_geo  // Geo-redirect page (store chooser, ZIP picker) - NOT a provider failure
}

enum FetchProvider {
  http
  mobile_ua
  headless
  flaresolverr
  brightdata
  scraping_browser
  twocaptcha_proxy
  twocaptcha_datadome
}

enum BlockKind {
  cloudflare
  datadome
  perimeterx
  captcha
}

/// Domain tier classification for SLO expectations and cost management
/// - tier_a: HTTP-first, SLO ≥95% on free providers (default for most sites)
/// - tier_b: Paid-first, SLO ≥95% with explicit budget (Amazon, Etsy)
/// - tier_c: Hostile/best-effort, lower SLO expected, higher cost (Temu, DataDome sites)
enum DomainTier {
  tier_a
  tier_b
  tier_c
  unknown
}

enum RuleType {
  price
  availability
  text
  number
  json_field
}

enum AlertSeverity {
  low
  medium
  high
  critical
}

enum AlertType {
  value_changed       // Price/availability change
  schema_drift        // Schema structure changed
  market_context      // Currency or country changed
  budget_exceeded     // Cost limit reached
  provider_error      // Fetch provider failing
  extraction_error    // Can't extract data
  threshold_alert     // Custom threshold triggered
}

enum NotificationChannelType {
  email
  telegram      // Keep for backwards compatibility
  slack         // Keep for backwards compatibility
  slack_oauth   // NEW
  discord       // NEW
  push          // NEW
  webhook
}

enum ChangeKind {
  new_value
  value_changed
  value_disappeared
  format_changed
  threshold_exceeded
}

// =====================
// MODELS
// =====================

model User {
  id                String             @id @default(cuid())
  email             String             @unique
  passwordHash      String             @map("password_hash")
  createdAt         DateTime           @default(now()) @map("created_at")
  lastLoginAt       DateTime?          @map("last_login_at")

  ownedWorkspaces   Workspace[]        @relation("WorkspaceOwner")
  workspaceMemberships WorkspaceMember[]

  @@map("users")
}

model Workspace {
  id        String        @id @default(cuid())
  ownerId   String        @map("owner_id")
  type      WorkspaceType
  name      String
  timezone  String        @default("UTC")
  createdAt DateTime      @default(now()) @map("created_at")

  owner     User          @relation("WorkspaceOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members   WorkspaceMember[]
  sources   Source[]
  fetchProfiles FetchProfile[]
  notificationChannels NotificationChannel[]

  @@index([ownerId])
  @@map("workspaces")
}

model WorkspaceMember {
  id          String        @id @default(cuid())
  workspaceId String        @map("workspace_id")
  userId      String        @map("user_id")
  role        WorkspaceRole
  joinedAt    DateTime      @default(now()) @map("joined_at")

  workspace   Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, userId])
  @@index([userId])
  @@map("workspace_members")
}

model FetchProfile {
  id              String    @id @default(cuid())
  workspaceId     String    @map("workspace_id")
  name            String
  mode            FetchMode @default(http)
  userAgent       String?   @map("user_agent")
  cookies         Json?
  headers         Json?
  proxyPool       String?   @map("proxy_pool")
  renderWaitMs    Int?      @map("render_wait_ms")
  screenshotOnChange Boolean @default(false) @map("screenshot_on_change")
  // Domain policy: preferred provider for paid-first routing
  preferredProvider     FetchProvider? @map("preferred_provider")
  // FlareSolverr wait time after challenge (seconds, default: instant)
  flareSolverrWaitSeconds Int?       @map("flaresolverr_wait_seconds")
  // PR4: Disabled providers (won't be tried for this profile)
  disabledProviders     FetchProvider[] @default([]) @map("disabled_providers")
  // PR4: Stop after preferred provider failure (don't try other providers)
  stopAfterPreferredFailure Boolean @default(false) @map("stop_after_preferred_failure")
  // Geo pinning: ISO 3166-1 alpha-2 country code for BrightData proxy location
  // Use this for currency stability (e.g., "cz" for Czech prices, "de" for German)
  geoCountry      String?   @map("geo_country")
  // Domain tier classification for SLO expectations and cost management
  // - tier_a: HTTP-first, SLO ≥95% on free providers (default for most sites)
  // - tier_b: Paid-first, SLO ≥95% with explicit budget (Amazon, Etsy)
  // - tier_c: Hostile/best-effort, lower SLO expected, higher cost (Temu, DataDome sites)
  domainTier      DomainTier @default(tier_a) @map("domain_tier")
  // Explicit tier policy overrides (JSONB) - fields here take precedence over tier defaults
  // Structure: { disabledProviders?: FetchProvider[], stopAfterPreferredFailure?: boolean,
  //              preferredProvider?: FetchProvider, timeouts?: { [provider]: number }, geoCountry?: string }
  tierPolicyOverrides Json?  @map("tier_policy_overrides")
  createdAt       DateTime  @default(now()) @map("created_at")

  workspace       Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  sources         Source[]

  @@index([workspaceId])
  @@map("fetch_profiles")
}

model Source {
  id              String        @id @default(cuid())
  workspaceId     String        @map("workspace_id")
  url             String
  canonicalUrl    String?       @map("canonical_url")
  domain          String
  fetchProfileId  String?       @map("fetch_profile_id")
  tags            Json?         @default("[]")
  enabled         Boolean       @default(true)
  createdAt       DateTime      @default(now()) @map("created_at")

  workspace       Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  fetchProfile    FetchProfile? @relation(fields: [fetchProfileId], references: [id], onDelete: SetNull)
  rules           Rule[]

  @@index([workspaceId])
  @@index([domain])
  @@index([fetchProfileId])
  @@map("sources")
}

model Rule {
  id                 String    @id @default(cuid())
  sourceId           String    @map("source_id")
  name               String
  ruleType           RuleType  @map("rule_type")
  extraction         Json      // selector, jsonPath, regex config
  selectorFingerprint Json?    @map("selector_fingerprint") // auto-healing: alternativeSelectors, textAnchor, parentContext
  schemaFingerprint   Json?    @map("schema_fingerprint") // schema.org drift detection: shapeHash, schemaTypes
  normalization      Json?     // transform, unit conversion config
  schedule           Json      // cron, interval config
  alertPolicy        Json?     @map("alert_policy") // thresholds, conditions
  enabled            Boolean   @default(true)
  screenshotOnChange Boolean   @default(false) @map("screenshot_on_change")
  healthScore        Float?    @map("health_score") @default(100.0)
  lastErrorCode String?   @map("last_error_code")
  lastErrorAt   DateTime? @map("last_error_at")
  nextRunAt     DateTime? @map("next_run_at")
  createdAt     DateTime  @default(now()) @map("created_at")
  // Captcha/2captcha cost limitation - auto-switch to 1 day interval
  captchaIntervalEnforced Boolean   @default(false) @map("captcha_interval_enforced")
  originalSchedule        Json?     @map("original_schedule") // original schedule before captcha enforcement
  autoThrottleDisabled    Boolean   @default(false) @map("auto_throttle_disabled") // user explicitly disabled auto-throttle

  source        Source    @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  state         RuleState?
  runs          Run[]
  observations  Observation[]
  alerts        Alert[]

  @@index([sourceId])
  @@index([nextRunAt])
  @@index([enabled, nextRunAt])
  @@map("rules")
}

model RuleState {
  id             String   @id @default(cuid())
  ruleId         String   @unique @map("rule_id")
  lastStable     Json?    @map("last_stable") // last confirmed stable value
  candidate      Json?    // potential new value
  candidateCount Int      @default(0) @map("candidate_count") // confirmation counter
  version        Int      @default(0) // optimistic locking version
  updatedAt      DateTime @default(now()) @updatedAt @map("updated_at")

  rule           Rule     @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@map("rule_state")
}

model Run {
  id              String    @id @default(cuid())
  ruleId          String    @map("rule_id")
  startedAt       DateTime  @default(now()) @map("started_at")
  finishedAt      DateTime? @map("finished_at")
  fetchModeUsed   FetchMode @map("fetch_mode_used")
  httpStatus      Int?      @map("http_status")
  errorCode       String?   @map("error_code")
  errorDetail     String?   @map("error_detail")
  timings         Json?     // fetch, parse, process timings
  blockDetected   Boolean   @default(false) @map("block_detected")
  contentHash     String?   @map("content_hash") // hash of extracted content
  rawSample       String?   @map("raw_sample") // sample of raw HTML/JSON
  screenshotPath  String?   @map("screenshot_path")

  rule            Rule      @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  observations    Observation[]

  @@index([ruleId])
  @@index([startedAt])
  @@map("runs")
}

model Observation {
  id                   String      @id @default(cuid())
  runId                String      @map("run_id")
  ruleId               String      @map("rule_id")
  extractedRaw         String?     @map("extracted_raw") // raw extracted value
  extractedNormalized  Json?       @map("extracted_normalized") // normalized value with metadata
  changeDetected       Boolean     @default(false) @map("change_detected")
  changeKind           ChangeKind? @map("change_kind")
  diffSummary          String?     @map("diff_summary") // human-readable diff
  createdAt            DateTime    @default(now()) @map("created_at")

  run                  Run         @relation(fields: [runId], references: [id], onDelete: Cascade)
  rule                 Rule        @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([runId])
  @@index([ruleId])
  @@index([changeDetected, createdAt])
  @@map("observations")
}

model Alert {
  id              String        @id @default(cuid())
  ruleId          String        @map("rule_id")
  triggeredAt     DateTime      @default(now()) @map("triggered_at")
  severity        AlertSeverity
  alertType       AlertType?    @map("alert_type") // Structured type for filtering/analytics
  title           String
  body            String        @db.Text
  metadata        Json?         // Structured data: old/new values, currency, country, etc.
  channelsSent    Json?         @map("channels_sent") // which channels received this alert
  dedupeKey       String        @unique @map("dedupe_key") // prevent duplicate alerts
  acknowledgedAt  DateTime?     @map("acknowledged_at")
  acknowledgedBy  String?       @map("acknowledged_by")
  resolvedAt      DateTime?     @map("resolved_at")

  rule            Rule          @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([ruleId])
  @@index([triggeredAt])
  @@index([dedupeKey])
  @@index([alertType])
  @@map("alerts")
}

model NotificationChannel {
  id              String                  @id @default(cuid())
  workspaceId     String                  @map("workspace_id")
  type            NotificationChannelType
  name            String
  configEncrypted String                  @map("config_encrypted") @db.Text // encrypted JSON config
  enabled         Boolean                 @default(true)
  createdAt       DateTime                @default(now()) @map("created_at")

  workspace       Workspace               @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@index([type, enabled])
  @@map("notification_channels")
}

model FetchAttempt {
  id            String        @id @default(cuid())
  workspaceId   String        @map("workspace_id")
  ruleId        String?       @map("rule_id")
  url           String
  hostname      String
  provider      FetchProvider
  outcome       FetchOutcome
  blockKind     BlockKind?    @map("block_kind")
  httpStatus    Int?          @map("http_status")
  finalUrl      String?       @map("final_url")
  bodyBytes     Int           @map("body_bytes")
  contentType   String?       @map("content_type")
  latencyMs     Int?          @map("latency_ms")
  signalsJson   Json?         @map("signals_json")
  errorDetail   String?       @map("error_detail")
  costUsd       Float         @default(0) @map("cost_usd")
  costUnits     Float?        @map("cost_units")
  createdAt     DateTime      @default(now()) @map("created_at")

  @@index([workspaceId, hostname, createdAt])
  @@index([workspaceId, provider, createdAt])
  @@index([ruleId, createdAt])
  @@index([hostname, outcome, createdAt])
  @@map("fetch_attempts")
}

model DomainStats {
  id              String    @id @default(cuid())
  workspaceId     String    @map("workspace_id")
  hostname        String
  date            DateTime  @db.Date
  attempts        Int       @default(0)
  okCount         Int       @default(0) @map("ok_count")
  blockedCount    Int       @default(0) @map("blocked_count")
  emptyCount      Int       @default(0) @map("empty_count")
  timeoutCount    Int       @default(0) @map("timeout_count")
  costUsd         Float     @default(0) @map("cost_usd")
  avgLatencyMs    Int?      @map("avg_latency_ms")
  byProviderJson  Json?     @map("by_provider_json")

  @@unique([workspaceId, hostname, date])
  @@index([workspaceId, date])
  @@map("domain_stats")
}
